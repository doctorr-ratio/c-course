# Занятие 4

#### 20.11.2020

## Многомерные массивы. Указатели. Адреса. Ссылки. Строки

### Многомерные массивы
В C кроме одномерных есть еще многомерные статические массивы. Синтаксис объявления у них сходный с одномерными: `int iArray2D[4][3];` -- двумерный массив типа `int`, `float fArray3D[4][5][6];` -- трехмерный массив типа `float`. В памяти такие массивы располагаются так же, как и одномерные, в одной области, элементы расположены последовательно. В языке C элементы `iArray2D[3][1]` и `iArray2D[3][2]` расположены в памяти последовательно. То есть порядковый номер в области памяти можно посчитать как `3*4+2`. Предположим, что у нас есть массив `int a[2][2]`, тогда его элементы в памяти расположены так (в порядке возрастания адреса): `a[0][0], a[0][1], a[1][0], a[1][1]`.

Зная это, а так же то, что в C часто нет проверки выхода индекса за допустимые массивы, можно обращаться ко всем элементам массива, меняя лишь один индекс (последний):
```
float fArray3D[4][5][6];

fArray3D[2][3][2] = 42;
printf("%f\n", fArray3D[0][0][2 + 3 * 6 + 2 * 5 * 6]); // выведет 42
```

Многомерные массивы при создании можно инициализировать. Если инициализаторов меньше, чем элементов массива, то остатки заполняются нулями. Для примера объявим единичную матрицу 3х3:
```
int matrix[3][3] = {{1}, {0, 1}, {0, 0, 1}};
```

Более подробно можно прочитать тут : [https://learnc.info/c/multidimensional_arrays.html](https://learnc.info/c/multidimensional_arrays.html)

### Указатели, адреса, операторы `*` и `&`
Ключевым понятием для осознания работы языка C являются **указатели**. Для каждого типа в C есть указатель. Что это такое? Это некоторый объект, хранящий информацию об **адресе** какой-либо переменной в адресном пространстве компьютера. Рассмотрим это на примере:
```
#include <stdio.h>
   
void main() {
    int A = 100;
    int *p;// Объявляем указатель на переменную типа int
 
    // Получаем адрес переменной A
    p = &A;
 
    // Выводим адрес переменной A, для указателей используется спецификатор %p
    printf("%p\n", p);
 
    // Выводим содержимое переменной A
    printf("%d\n", *p);
 
    // Меняем содержимое переменной A
    *p = 200;
 
    printf("%d\n", A);
    printf("%d", *p);
}
```
Про объявление указателей удобно думать так: мы объявляем переменную типа `int`, которая называется `*p`, но если мы пишем `p`, то это уже не `int`, а указатель на `int`.

Если же мы объявили переменную с "нормальным" именем, то есть не начинающимся с `*`, то чтобы получить ее адрес (чтобы присвоить указателю, например), мы напишем перед ее именем оператор получения адреса `&`.

Указатели поддерживают арифметические операции с собой. Например, операция `+ N`, где `N` -- целое число, "сдвигает" указатель вперед на N*sizeof(тип указателя) байт.

Понятие указателя очень тесно связано с понятием массива в языке C. Не забывая про арифметику указателей, рассмотрим следующий пример:
```
#include <stdio.h>
   
void main() {
    int A[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int *p;
 
    p = A;
 
    printf("%d\n", *p); // выведет 1
    p++;
    printf("%d\n", *p); // выведет 2
    p = p + 4;
    printf("%d\n", *p); // выведет 6
}
```
Так как массив сам по себе фактически является указателем на свой первый элемент, то запись `p = A;` скомпилировалась без проблем с типами.

Подробнее про указатели (и их связь с массивами) советую почитать тут: 

+ [https://learnc.info/c/pointers.html](https://learnc.info/c/pointers.html)
+ [https://learnc.info/c/arrays_vs_pointers.html](https://learnc.info/c/arrays_vs_pointers.html)


### Строки
Как вы ужt возможно подозреваете, строки в C -- не отдельный тип данных, а массив типа `char`. Однако есть несколько приспособлений, упрощающих работу со строками. В частности это спецификатор вывода `%s`. При его указании в `printf();` мы можем передавать строку целиком сразу, а не поэлементно.

При чтении строк спецификатор может быть дополнен указанием максимально допустимого размера считываемой строки: `%19s` -- по указанному в `scanf()` адресу будет записано только 19 байт "основного содержания" и 20-й байт с символом `\0` (терминатор строки).

Пример:
```
#include <stdio.h>
  
void main() {
    char buffer[20]; // Объявляем массив на 20 символов, с учетом завершающего \0
 
    scanf("%19s", buffer); // Считываем максимум 19 символов
    printf("%s", buffer); // Выводим то, что считали
}
```
Ограничивать максимальную длину считываемой строки необходимо, потому что если считается больше, то затрутся данные за пределами выделенной под массив области памяти, что может привести к ошибкам в работе программы, причем не всегда легко заметным. Выбор размера "буфера" должен быть адекватен решаемой задаче.



## Домашнее задание

#### 0
Написать программу, которая запрашивает у пользователя 15 действительных чисел и возвращает их среднее арифметическое, геометрическое и гармоническое. Сделать так, чтобы количество чисел при необходимости можно было изменить всего в одном месте (используйте директиву `define`).

#### 1
Напишите программу, которая считывает строку, определяет ее длину (без использования string.h) и выводит ее.

#### 2
Напишите программу, которая считывает 2 строки и проверяет их на равенство, после чего выводит результат проверки (без использования string.h) и количество символов до первого расхождения. Для строк "effort" и "effect" вывод будет "не равны" и 3, потому что первые три символа совпадают, а 4-е символы уже расходятся. Постарайтесь написать программу "экономично" -- нет нужды продолжать проверку, если несовпадение уже нашлось (оператор `break`).

#### 3*
Объявите массив типа `char` размера 16x16. Пользователь последовательно вводит 16 значений, допустимый диапазон от 0 до 16, считывается в переменную `n` типа `int`, если число в него не входит, заменить его 0 и выводить предупреждение для пользователя. После считывания i-го числа заполнить первые `n` элементов звездочками `*`, остальные пробелами. Вывести массив построчно, каждую строку на новой строке.

#### 4* (необязательная)
Напишите программу, принимающую на вход строку, ограниченную по длине 16 **значащими** символами. Если строка короче, дозаполнить символом пробела до 16 символов. Сделать из первых 8 элементов строки палиндром, вывести то, что получилось. Например: вводим "abcdefghijklmnop", выводим "abcdefghhgfedcba", вводим "привет", выводим "привет    тевирп".

#### 5** (необязательная)
Дан код программы вычисления эвклидового и манхэттенского расстояния между точками старта и финиша на карте (роль карты играет массив `field`). Модифицировать программу для работы с трехмерной картой (для простоты 3х3х3).
Необходимая математика для решения:
[Манхэттенское расстояние](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D1%85_%D0%BA%D0%B2%D0%B0%D1%80%D1%82%D0%B0%D0%BB%D0%BE%D0%B2)
[Эвклидово расстояние](https://ru.wikipedia.org/wiki/%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0)
```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
 
#define SIZE 5
#define START  2
#define FINISH 3
 
void main() {
    char field[SIZE][SIZE] = {
        {0, 0, 0, 0, 0},
        {2, 0, 3, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0}
    };
    unsigned i, j;
    unsigned x, y;
    char xFound = 0;
    int X, Y;
    char XFound = 0;
    unsigned manhattanDist;
    float euclidDist;
 
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            if (field[i][j] == START) {
                x = i;
                y = j;
                xFound = 1;
                if (XFound) {
                    break;
                }
            }
            if (field[i][j] == FINISH) {
                X = i;
                Y = j;
                XFound = 1;
                if (xFound) {
                    break;
                }
            }
        }
        if (xFound && XFound) {
            break;
        }
    }
    if (!(xFound && XFound)) {
        printf("Error: corrupted data\n");
        exit(1);
    }
 
    printf("(x,y) = %d, %d\n(X,Y)= %d, %d\n", x, y, X, Y);
 
    manhattanDist = abs((int)(x-X)) + abs((int)(y-Y));
    euclidDist = sqrt((float)(x-X)*(float)(x-X)+(float)(y-Y)*(float)(y-Y));
    printf("Manhattan dist. = %d\nEuclid dist. = %.3f\n", manhattanDist, euclidDist);
}
```

